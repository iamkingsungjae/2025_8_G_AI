"""카테고리별 텍스트 생성기"""
from typing import Dict, List
from anthropic import Anthropic
import logging

logger = logging.getLogger(__name__)


class CategoryTextGenerator:
    """카테고리별 메타데이터를 자연어 텍스트로 변환 (LLM 사용)"""

    def __init__(self, api_key: str):
        """
        Args:
            api_key: Anthropic API 키
        """
        self.client = Anthropic(api_key=api_key)
        self.model = "claude-haiku-4-5-20251001"  #  haiku 사용

        #  공통 프롬프트 템플릿 (하나의 통합 구조)
        self.master_template = """
메타데이터: {metadata}

다음 조건을 반드시 지키면서 자연스러운 한국어 문장을 **한 문장만** 생성하세요.

[공통 규칙]

1. 반드시 주어진 메타데이터 정보만 사용하세요. **추가 추론, 상상, 일반화는 절대 하지 마세요.**

2. 메타데이터에 명시되지 않은 **직업, 감정, 이유, 원인, 성격, 해석 등**은 넣지 마세요.

3. **부분 정보만 있어도 반드시 문장을 생성하세요.** 메타데이터가 하나만 있어도 그것을 활용하여 자연스러운 문장을 만드세요.

4. 자연스럽고 간결한 한국어 문장으로 작성하되, **사실의 정확성**을 가장 우선시하세요.

5. 존댓말을 사용하세요. (입니다/합니다 등)

6. 출력은 **문장 하나만**, 따옴표, 번호, 마크다운 없이 반환하세요.

7. 카테고리 이름은 문장에 포함하지 마세요.

카테고리: 기본정보  

메타데이터: 지역: 서울

→ 문장: 서울에 거주하고 있습니다.

카테고리: 기본정보  

메타데이터: 지역: 서울, 연령대: 20대  

→ 문장: 서울에 거주하는 20대입니다.

카테고리: 직업소득

메타데이터: 직업: 회사원

→ 문장: 회사원으로 근무하고 있습니다.

카테고리: 흡연

메타데이터: 흡연: 경험

→ 문장: 흡연 경험으로 담배를 사용한 경험이 있습니다.

카테고리: 음주

메타데이터: 음주: 경험

→ 문장: 음주 경험으로 술을 음용한 경험이 있습니다.

{category_instruction}

""".strip()

        #  카테고리별 세부 지침 (QuickPoll 문장 구조 포함)
        self.category_instructions = {
            "기본정보": """메타데이터: {metadata}

위 정보를 바탕으로 벡터DB에 저장된 스타일로 자연스러운 한 문장을 생성하세요.

참고 예시 (벡터DB 스타일):

- "서울에 거주하는 25세 여성으로 미혼이며, 1명의 가족 구성원으로 혼자 거주하고 있습니다."

- "부산에 사는 30대 남성으로 기혼이며, 3명의 가족과 함께 거주합니다."

- "경기도에 거주하는 42세 여성으로 대학교를 졸업했습니다."

규칙:

1. 자연스러운 한국어 문장으로 작성

2. 존댓말 사용 (입니다/습니다)

3. 지역, 나이, 성별 정보를 자연스럽게 연결

4. 카테고리 이름을 포함하지 말 것

5. 주어진 메타데이터로 자연스러운 문장 만들 것(메타데이터가 어떤 것만 있으니 그에 대한 문장만 만들었다는 이유는 출력하지말 것)

문장만 출력하세요:""",

            "직업소득": """메타데이터: {metadata}

위 정보를 바탕으로 벡터DB에 저장된 정확한 스타일로 직업과 소득 문장을 생성하세요.

 [필수 규칙 - 절대 지켜야 함!]

메타데이터에 **있는 정보만** 사용하여 문장을 생성하세요. 없는 정보는 절대 포함하지 마세요.

[조합별 생성 규칙]

1. 직업 + 직무 + 개인소득 + 가구소득:

"{직업} (예시)으로 {직무} 분야에서 근무하며 월평균 개인소득은 월 {값}이고 가구 월평균 소득은 월 {값}입니다."

2. 직업 + 개인소득 + 가구소득 (직무 없음):

"{직업}으로 근무하며 월평균 개인소득은 월 {값}이고 가구 월평균 소득은 월 {값}입니다."

3. 개인소득 + 가구소득만 (직업 없음):

"월평균 개인소득은 월 {값}이고 가구 월평균 소득은 월 {값}입니다."

4. 직업만 (소득 없음):

"{직업}으로 근무하고 있습니다."

5. 직업 + 직무만 (소득 없음):

"{직업} (예시)으로 {직무} 분야에서 근무하고 있습니다."

6. 개인소득만 (가구소득 없음):

"월평균 개인소득은 월 {값}입니다."

7. 가구소득만 (개인소득 없음):

"가구 월평균 소득은 월 {값}입니다."

8. 직업 + 개인소득만 (직무, 가구소득 없음):

"{직업}으로 근무하며 월평균 개인소득은 월 {값}입니다."

9. 직업 + 가구소득만 (직무, 개인소득 없음):

"{직업}으로 근무하며 가구 월평균 소득은 월 {값}입니다."

10. 직업 + 직무 + 개인소득만 (가구소득 없음):

"{직업} (예시)으로 {직무} 분야에서 근무하며 월평균 개인소득은 월 {값}입니다."

1.1. 직업 + 직무 + 가구소득만 (개인소득 없음):

"{직업} (예시)으로 {직무} 분야에서 근무하며 가구 월평균 소득은 월 {값}입니다."

1.2. 직무만 (소득 없음): ****메타데이터로 직무만 있어도 꼭 작성해야함.****

"{직무} 분야에서 근무합니다."

[핵심 조사 규칙]  매우 중요!

- 직업 뒤: 반드시 "으로" (퇴직/연금생활자으로, 요리사으로, 대학생/대학원생으로)

- 직무 표현: "{직무} 분야에서 근무합니다"

- 개인소득: "월평균 개인소득은 월" 

- 가구소득: "가구 월평균 소득은 월"  (앞에 "월평균" 없음!)

- 개인소득과 가구소득 둘 다 있을 때만: "이고"로 연결

- 마지막: "입니다"

참고 예시 (벡터DB 스타일):

- "전문직 (의사, 간호사, 변호사, 회계사, 예술가, 종교인, 엔지니어, 프로그래머, 기술사 등)으로 의료•간호•보건•복지 분야에서 근무하며 월평균 개인소득은 월 500~599만원이고 가구 월평균 소득은 월 700~799만원입니다."

- "퇴직/연금생활자으로 근무하며 월평균 개인소득은 월 200~299만원이고 가구 월평균 소득은 월 300~399만원입니다."

- "월평균 개인소득은 월 200~299만원이고 가구 월평균 소득은 월 200~299만원입니다."

- "대학생/대학원생으로 근무하고 있습니다."

- "마케팅•광고•홍보•조사 분야에서 근무합니다."

- "고객상담•TM 분야에서 근무합니다."

- "전업주부으로 근무하며 월평균 개인소득은 월 200~299만원입니다."

 절대 금지:

- 메타데이터에 없는 정보를 구조상 필요하다고 임의로 추가하지 마세요

- 빈 값이나 null, 무응답은 해당 항목을 완전히 생략하세요

문장만 출력하세요:""",

            "전자제품": """메타데이터: {metadata}

위 정보를 바탕으로 벡터DB에 저장된 정확한 스타일로 전자제품 보유 현황 문장을 생성하세요.

 [필수 형식 - 절대 지켜야 함!]

"보유 전자제품은 가전: [제품들] | IT: [제품들] | 생활: [제품들] 입니다."

규칙:

1. 반드시 "보유 전자제품은" 으로 시작

2. 가전, IT, 생활 3가지 카테고리로 분류

3. 카테고리는 " | " (공백+파이프+공백)로 구분

4. 각 카테고리 내 제품들은 ", " (쉼표+공백)로 구분

5. 생활 카테고리가 없으면 "가전: ... | IT: ... 입니다." 형태로 생략

6. 반드시 " 입니다." 로 종료

[전자제품 28개 분류]

가전: TV, 냉장고, 김치냉장고, 세탁기, 에어컨, 제습기, 공기청정기, 정수기, 일반청소기, 로봇청소기, 무선청소기, 커피 머신, 음식물 처리기, 건조기, 전기레인지, 식기세척기, 에어프라이기, 가정용 식물 재배기

IT: 노트북, 태블릿PC, 데스크탑, 무선 이어폰, 스마트 워치, 인공지능 AI 스피커, 블루투스 스피커

생활: 안마의자, 비데, 의류 관리기

참고 예시 (벡터DB 스타일):

- "보유 전자제품은 가전: TV, 냉장고, 세탁기, 에어컨, 제습기, 공기청정기, 정수기, 로봇청소기, 무선청소기, 커피 머신, 건조기, 에어프라이기 | IT: 노트북, 태블릿PC, 데스크탑, 무선 이어폰, 스마트 워치, 인공지능 AI 스피커, 블루투스 스피커 | 생활: 안마의자, 비데, 의류 관리기 입니다."

- "보유 전자제품은 가전: TV, 냉장고, 세탁기, 제습기, 공기청정기, 일반청소기, 건조기 | IT: 데스크탑, 무선 이어폰, 블루투스 스피커 입니다."

- "보유 전자제품은 가전: 세탁기, 에어컨 입니다."

 주의: 제품명은 위 분류표의 정확한 이름 그대로 사용할 것!

문장만 출력하세요:""",

            "모바일·자동차": """메타데이터: {metadata}

위 정보를 바탕으로 벡터DB에 저장된 정확한 스타일로 휴대폰과 자동차 보유 현황 문장을 생성하세요.

 [필수 형식 - 절대 지켜야 함!]

1. 휴대폰만 있는 경우: "휴대폰은 {브랜드} 브랜드의 {모델} 모델을 사용하고 있습니다."

2. 자동차만 있는 경우: "{제조사}의 {차량명} 차량을 보유하고 있습니다."

3. 둘 다 있는 경우: "휴대폰은 {브랜드} 브랜드의 {모델} 모델을 사용하고 있습니다. {제조사}의 {차량명} 차량을 보유하고 있습니다."

4. 자동차 없는 경우: "보유하고 있는 자동차가 없습니다."

5. 제조사와 차량명 없이 자동차 있는 경우: "어떤제조사의 어떤차량을 보유하고 있습니다." **다른 설명없이 해당 문장만 생성할 것**

규칙:

1. 휴대폰 정보가 있으면 반드시 "휴대폰은 ... 브랜드의 ... 모델을 사용하고 있습니다." 형식 사용

2. 자동차 정보가 있으면 반드시 "...의 ... 차량을 보유하고 있습니다." 형식 사용

3. 둘 다 있으면 휴대폰 문장 + 공백 하나 + 자동차 문장

4. 메타데이터에 있는 정보만 사용 (없는 것은 생략)

참고 예시 (벡터DB 스타일):

- "휴대폰은 삼성전자 브랜드의 갤럭시 Z Filp 시리즈 모델을 사용하고 있습니다. 기아의 레이 차량을 보유하고 있습니다."

- "휴대폰은 LG전자 브랜드의 LG V 시리즈 모델을 사용하고 있습니다."

- "휴대폰은 삼성전자 브랜드의 갤럭시 A 시리즈 모델을 사용하고 있습니다. 현대의 아반떼 차량을 보유하고 있습니다."

문장만 출력하세요:""",

            "흡연": """메타데이터: {metadata}

위 정보를 바탕으로 벡터DB에 저장된 정확한 스타일로 흡연 경험 문장을 생성하세요.

 [필수 형식 - 절대 지켜야 함!]

1. 흡연 경험 없음: "흡연 경험은 없습니다."

2. 흡연 경험 있음 (담배 종류 + 브랜드): "흡연 경험으로 {담배종류들}를 사용한 경험이 있으며 사용한 담배 브랜드는 {브랜드들}입니다."

3. 흡연 경험 있음 (담배 종류만): "흡연 경험으로 {담배종류들}를 사용한 경험이 있습니다."

**[상세 정보가 있을 때]**

- "일반 담배, 궐련형 전자담배, 액상형 전자담배 등 다양한 흡연 경험이 있으며, 말보로 담배와 글로 가열식 담배를 사용한 경험이 있습니다."

- "일반 담배, 궐련형 전자담배, 액상형 전자담배 등 다양한 흡연 경험이 있습니다. 디스플러스, 말보로, 팔리아멘트, 던힐 등의 담배 브랜드를 사용했으며, 아이코스와 글로 같은 궐련형 전자담배도 이용한 경험이 있습니다."

**[부분 정보만 있을 때 - 중요!]**

- 메타데이터: 흡연: 경험 → "흡연 경험으로 담배를 피운 경험이 있습니다."

- 메타데이터: 흡연: 일반 담배 → "일반 담배를 피운 경험이 있습니다."

- 메타데이터: 흡연: 궐련형 전자담배 → "궐련형 전자담배를 사용한 경험이 있습니다."

- 메타데이터: 흡연: 일반 담배, 궐련형 전자담배 → "일반 담배와 궐련형 전자담배를 피운 경험이 있습니다."

규칙:

1. 비흡연자는 반드시 "흡연 경험은 없습니다."

2. 흡연자는 "흡연 경험으로 ... 사용한 경험이 있으며" 형식

3. 여러 담배 종류는 ", " (쉼표+공백)로 구분

4. 여러 브랜드는 ", " (쉼표+공백)로 구분

5. 브랜드 정보가 없으면 "...를 사용한 경험이 있습니다."로 종료

참고 예시 (벡터DB 스타일):

- "흡연 경험은 없습니다."

- "흡연 경험으로 일반 담배를 사용한 경험이 있으며 사용한 담배 브랜드는 말보로입니다."

- "흡연 경험으로 일반 담배를 사용한 경험이 있으며 사용한 담배 브랜드는 한라산입니다."

- "흡연 경험으로 일반 담배, 궐련형 전자 담배/ 가열식 담배 ((예) 아이코스, 글로, 릴만 해당 됨), 액상형 전자담배 ((예) 저스트포그 등)를 사용한 경험이 있으며 사용한 담배 브랜드는 레종, 에쎄, 더원, 디스플러스, 디스, 라일락, 심플, 타임, 88리턴즈, 말보로, 팔리아멘트, 메비우스(구 마일드세븐), 던힐, 버지니아 S입니다."

문장만 출력하세요:""",

            "음주": """메타데이터: {metadata}

위 정보를 바탕으로 벡터DB에 저장된 정확한 스타일로 음주 경험 문장을 생성하세요.

 [필수 형식 - 절대 지켜야 함!]

1. 최근 1년 음주 안함: "최근 1년 이내 술을 마시지 않았습니다."

2. 음주 경험 있음: "음용 경험으로 {술종류들}를 음용한 경험이 있습니다."

**[상세 정보가 있을 때]**

- "소주, 맥주, 저도주, 막걸리/탁주, 양주, 와인, 과일칵테일주 등 다양한 종류의 술을 음용한 경험이 있습니다."

- "소주를 음용한 경험이 있습니다."

- "최근 1년 이내에 술을 마시지 않았으며, 현재 음주 활동이 없습니다."

**[부분 정보만 있을 때 - 중요!]**

- 메타데이터: 음주: 경험 → "음주 경험으로 소주나 맥주같은 술을 음용한 경험이 있습니다."

- 메타데이터: 음주: 소주 → "소주를 마신 경험이 있습니다."

- 메타데이터: 음주: 맥주 → "맥주를 마신 경험이 있습니다."

- 메타데이터: 음주: 소주, 맥주 → "소주와 맥주를 마신 경험이 있습니다."

- 메타데이터: 음주: 와인 → "와인을 음용한 경험이 있습니다."

규칙:

1. 비음주자는 반드시 "최근 1년 이내 술을 마시지 않았습니다."

2. 음주자는 반드시 "음용 경험으로 ... 음용한 경험이 있습니다." 형식

3. 여러 술 종류는 ", " (쉼표+공백)로 구분

4. "를" 조사 사용 (예: "소주를", "와인를")

참고 예시 (벡터DB 스타일):

- "최근 1년 이내 술을 마시지 않았습니다."

- "음용 경험으로 소주, 맥주, 저도주 (맥주, 막걸리, 와인 등을 제외한 18도 미만의 술), 막걸리/탁주, 와인를 음용한 경험이 있습니다."

- "음용 경험으로 소주를 음용한 경험이 있습니다."

- "음용 경험으로 소주, 와인를 음용한 경험이 있습니다."

- "음용 경험으로 소주, 맥주, 막걸리/탁주, 양주 (위스키, 보드카, 데킬라, 진 등), 와인를 음용한 경험이 있습니다."

문장만 출력하세요:""",

            "스트레스": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 스트레스_원인 → "가장 스트레스를 많이 느끼는 상황은 {값}입니다."

- 스트레스_해소 → "스트레스 해소는 주로 {값}를 통해 하고 있습니다."

- 이사_스트레스 → "이사할 때는 {값}에서 가장 스트레스를 받습니다."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 이사_스트레스: "스트레스 받지 않는다" → "이사할 때는 특별히 스트레스를 받지 않는 편입니다."

참고 예시 (벡터DB 스타일):

- "가장 스트레스를 많이 느끼는 상황은 인간관계 (가족, 친구, 직장 등)입니다."

- "스트레스 해소는 주로 운동을 통해 하고 있습니다."

- "이사할 때는 비용 부담에서 가장 스트레스를 받습니다."

규칙:

1. QuickPoll 메타데이터(스트레스_원인, 스트레스_해소, 이사_스트레스)는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "미용": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 피부_만족도 → "현재 본인의 피부 상태에 대해서는 {값}고 느끼고 있습니다."

- 스킨케어_지출 → "한 달 기준 스킨케어 제품에는 평균적으로 {값} 정도 소비하고 있습니다."

- 스킨케어_구매기준 → "스킨케어 제품을 구매할 때는 {값}을 가장 중요하게 고려합니다."

참고 예시 (벡터DB 스타일):

- "현재 본인의 피부 상태에 대해서는 보통이라고 느끼고 있습니다."

- "한 달 기준 스킨케어 제품에는 평균적으로 3만원 미만 정도 소비하고 있습니다."

- "스킨케어 제품을 구매할 때는 성분 및 효과를 가장 중요하게 고려합니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "소비": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 전통시장_방문 → "전통시장은 {값} 정도의 빈도로 방문하고 있습니다."

- 설선물_선호 → "설 선물로는 {값} 유형을 가장 선호합니다."

- 기분좋은_소비 → "본인을 위해 소비하는 것 중 가장 기분 좋아지는 소비는 {값}입니다."

- 빠른배송_제품 → "빠른 배송 서비스는 주로 {값}을 구매할 때 이용합니다."

- 최다_지출 → "최근 가장 지출이 많았던 분야는 {값}입니다."

- 캐시백_관심 → "포인트 적립 혜택은 {값}"

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 전통시장_방문: "전혀 방문하지 않음" → "전통시장은 전혀 방문하지 않는 편입니다."

- 설선물_선호: "선호하는 선물이 없다" → "설 선물에 대해서는 특별히 선호하는 유형이 없습니다."

- 빠른배송_제품: "빠른 배송 서비스를 이용해 본 적 없다" → "빠른 배송 서비스는 거의 이용해 본 적이 없습니다."

- 캐시백_관심: "전혀 관심 없다" → "포인트 적립 혜택에는 전혀 관심이 없습니다."

참고 예시 (벡터DB 스타일):

- "전통시장은 한 달에 1회 이상 정도의 빈도로 방문하고 있습니다."

- "설 선물로는 백화점 상품권/현금 유형을 가장 선호합니다."

- "본인을 위해 소비하는 것 중 가장 기분 좋아지는 소비는 여행 가기입니다."

- "빠른 배송 서비스는 주로 신선 식품을 구매할 때 이용합니다."

- "최근 가장 지출이 많았던 분야는 콘서트, 전시 등 문화생활입니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "미디어": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- OTT_이용개수 → "현재 이용 중인 OTT 서비스는 {값}입니다."

- 주사용_앱 → "요즘 가장 많이 사용하는 앱은 {값}입니다."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- OTT_이용개수: "이용하지 않는다" → "현재 OTT 서비스는 이용하지 않고 있습니다."

참고 예시 (벡터DB 스타일):

- "현재 이용 중인 OTT 서비스는 2개입니다."

- "요즘 가장 많이 사용하는 앱은 SNS 앱 (인스타그램, 페이스북, 틱톡 등)입니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "AI 서비스": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- AI_챗봇_사용 → "사용해 본 AI 챗봇 서비스는 {값}입니다."

- AI_챗봇_주사용 → "그중에서 주로 사용하는 AI 챗봇 서비스는 {값}입니다."

- AI_활용용도 → "AI 챗봇 서비스는 주로 {값} 용도로 활용하거나 앞으로 활용하고 싶습니다."

- AI_서비스_선호 → "ChatGPT와 딥시크 중에서는 {값}에 더 호감을 느끼고 있습니다."

- AI_활용분야 → "최근에는 {값} 분야에서 AI 서비스를 활용하고 있습니다."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- AI_챗봇_사용: "사용해 본 적 없음" → "AI 챗봇 서비스를 사용해 본 적이 없습니다."

- AI_챗봇_주사용: "사용해 본 적 없음" → "현재 주로 사용하는 AI 챗봇 서비스는 없습니다."

- AI_활용분야: "AI 서베스를 사용해본 적 없다" 또는 "AI 서비스를 사용해본 적 없다" → "요즘에는 특정 분야에서 AI 서비스를 활용하고 있지 않습니다."

참고 예시 (벡터DB 스타일):

- "사용해 본 AI 챗봇 서비스는 Copilot (마이크로소프트), Gemini (구글)입니다."

- "그중에서 주로 사용하는 AI 챗봇 서비스는 Copilot (마이크로소프트)입니다."

- "AI 챗봇 서비스는 주로 학습 및 과제 도움 용도로 활용하거나 앞으로 활용하고 싶습니다."

- "ChatGPT와 딥시크 중에서는 ChatGPT에 더 호감을 느끼고 있습니다."

- "최근에는 이미지 생성 또는 디자인 참고 분야에서 AI 서비스를 활용하고 있습니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "라이프스타일": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 알람_방식 → "아침에 기상하기 위해 주로 알람 방식을 {값}"

- 혼밥_빈도 → "혼자 외식하는 빈도는 {값} 입니다."

- 미니멀맥시멀 → "자신은 {값}에 더 가깝다고 생각합니다."

- 물건처리 → "버리기 아까운 물건은 주로 {값}합니다."

- 비닐_감소노력 → "일회용 비닐 사용을 줄이기 위해 {값}"

- 개인정보보호 → "개인정보보호를 위해 {값}."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 물건처리: "바로 버린다" → "버리기 아까운 물건은 바로 버리는 편입니다."

- 혼밥_빈도: "거의 하지 않거나 한 번도 해본 적 없다" → "혼자 외식을 거의 하지 않거나 한 번도 해본 적 없습니다."

- 비닐_감소노력: "따로 노력하고 있지 않다" → "일회용 비닐 사용을 줄이기 위해 따로 노력하고 있지 않습니다."

- 개인정보보호: "따로 실천하는 게 없다" → "개인정보보호를 위해 따로 실천하는 습관은 없습니다."

참고 예시 (벡터DB 스타일):

- "아침에 기상하기 위해 주로 알람 방식을 한 개만 설정하고 바로 일어납니다."

- "혼자 외식하는 빈도는 거의 하지 않음 입니다."

- "자신은 미니멀리스트에 더 가깝다고 생각합니다."

- "버리기 아까운 물건은 주로 중고로 판매합니다."

- "일회용 비닐 사용을 줄이기 위해 비닐 대신 종이봉투나 박스를 활용합니다."

- "개인정보보호를 위해 비밀번호를 주기적으로 바꿉니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "경험": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 겨울방학_기억 → "초등학생 시절 겨울방학 때 가장 기억에 남는 일은 {값}입니다."

- 갤러리_사진 → "휴대폰 갤러리에는 {값}이 가장 많이 저장되어 있습니다."

- 반려동물_경험 → "{값}"

- 노년_조건 → "행복한 노년을 위해 가장 중요하다고 생각하는 요소는 {값}입니다."

- 다이어트_방법 → "가장 효과 있었던 다이어트 방법은 {값}입니다."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 반려동물_경험: "반려동물을 키워본 적이 없다" → "반려동물을 키워본 적이 없습니다."

- 다이어트_방법: "없다" → "지금까지 효과가 있었던 다이어트 방법은 없습니다."

참고 예시 (벡터DB 스타일):

- "초등학생 시절 겨울방학 때 가장 기억에 남는 일은 가족과 함께 떠난 여행입니다."

- "휴대폰 갤러리에는 풍경/여행 사진이 가장 많이 저장되어 있습니다."

- "반려동물을 키워본 적이 있습니다."

- "행복한 노년을 위해 가장 중요하다고 생각하는 요소는 건강한 몸과 마음입니다."

- "가장 효과 있었던 다이어트 방법은 꾸준한 유산소 운동입니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "식습관": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 야식_방식 → "야식을 먹을 때는 주로 {값} 방식으로 먹습니다."

- 여름_간식 → "여름철 최애 간식은 {값}입니다."

- 초콜릿_섭취 → "초콜릿은 주로 {값} 때 먹습니다."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 야식_방식: "야식을 거의 먹지 않는다" → "야식은 거의 먹지 않는 편입니다."

- 여름_간식: "없다" → "여름철 최애 간식은 따로 없습니다."

- 초콜릿_섭취: "거의 먹지 않는다" → "초콜릿은 거의 먹지 않는 편입니다."

참고 예시 (벡터DB 스타일):

- "야식을 먹을 때는 주로 배달 음식 방식으로 먹습니다."

- "여름철 최애 간식은 아이스크림입니다."

- "초콜릿은 주로 간식으로 습관처럼 때 먹습니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "여행": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 여행_스타일 → "여행 스타일은 {값}에 더 가깝습니다."

- 물놀이_장소 → "여름철 선호하는 물놀이 장소는 {값}입니다."

- 해외여행_희망 → "올해 해외여행을 간다면 {값}로 가고 싶습니다."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 여행_스타일: "잘 모르겠다" → "여행 스타일에 대해서는 잘 모르겠다고 응답했습니다."

- 물놀이_장소: "물놀이를 좋아하지 않는다" → "여름철 물놀이는 특별히 좋아하지 않는 편입니다."

- 해외여행_희망: "해외여행을 가고싶지 않다" → "올해 해외여행을 가고 싶은 마음은 없습니다."

참고 예시 (벡터DB 스타일):

- "여행 스타일은 큰 틀만 정하고 세부 일정은 현지에서 정하는 반반형에 더 가깝습니다."

- "여름철 선호하는 물놀이 장소는 바다입니다."

- "올해 해외여행을 간다면 일본로 가고 싶습니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "계절": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

[QuickPoll 문장 구조]

- 여름_걱정 → "다가오는 여름철 가장 걱정되는 점은 {값}입니다."

- 땀_불편함 → "여름철 땀 때문에 겪는 가장 큰 불편함은 {값}입니다."

- 여름_패션필수템 → "여름철 절대 포기할 수 없는 패션 필수템은 {값}입니다."

- 비_대처 → "갑작스러운 비에 우산이 없을 때는 주로 {값}."

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 여름_걱정: "특별히 걱정되는 것이 없다" → "다가오는 여름철에 특별히 걱정되는 점은 없습니다."

- 땀_불편함: "특별히 불편한 점이 없다" → "여름철 땀으로 인한 불편함은 특별히 느끼지 않는 편입니다."

참고 예시 (벡터DB 스타일):

- "다가오는 여름철 가장 걱정되는 점은 더위와 땀입니다."

- "여름철 땀 때문에 겪는 가장 큰 불편함은 메이크업이 무너지는 것입니다."

- "여름철 절대 포기할 수 없는 패션 필수템은 선글라스입니다."

- "갑작스러운 비에 우산이 없을 때는 주로 근처 비를 피할 수 있는 곳으로 뛰어갑니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:""",

            "건강": """메타데이터: {metadata}

 QuickPoll 메타데이터가 있는 경우, 반드시 아래 문장 구조를 따라 생성하세요:

 [부정적 답변 처리 - 매우 중요!]

다음 부정적 답변은 반드시 지정된 문장으로 생성:

- 체력관리: "체력관리를 위해 하고 있는 활동이 없다" → "평소 체력 관리를 위해 하고 있는 활동은 없습니다."

[QuickPoll 문장 구조]

- 체력관리 → "평소 체력 관리를 위해 주로 하고 있는 활동은 {값}입니다."

참고 예시 (벡터DB 스타일):

- "평소 체력 관리를 위해 주로 하고 있는 활동은 헬스입니다."

- "평소 체력 관리를 위해 하고 있는 활동은 없습니다."

- "평소 체력 관리를 위해 주로 하고 있는 활동은 달리기/걷기입니다."

규칙:

1. QuickPoll 메타데이터는 위의 정확한 문장 구조 사용

2. 존댓말 사용 (입니다)

문장만 출력하세요:"""
        }

        self.default_instruction = "[카테고리 지침 없음]"

    def generate(self, category: str, metadata_items: List[str], full_metadata_dict: Dict[str, str] = None) -> str:
        """카테고리별 자연어 텍스트 생성 (API 인터페이스 유지)"""
        if not metadata_items:
            logger.warning(f"[WARN] metadata_items가 비어있음 ({category})")
            return ""

        metadata_dict = {}
        for item in metadata_items:
            if ": " in item:
                key, value = item.split(": ", 1)
                metadata_dict[key] = value
        
        try:
            text = self._generate_text_with_llm(category, metadata_dict)
            if text and text.strip():
                logger.info(f"[{category}] {text[:80]}...")
                return text
            else:
                # 빈 텍스트 반환 시 폴백
                fallback_text = ", ".join(metadata_items)
                logger.warning(f"[WARN] LLM이 빈 텍스트 반환 ({category}), 폴백 사용: {fallback_text}")
                return fallback_text
        except Exception as e:
            # 예외 발생 시 폴백
            fallback_text = ", ".join(metadata_items)
            logger.error(f"[ERROR] 텍스트 생성 실패 ({category}): {e}, 폴백 사용: {fallback_text}", exc_info=True)
            return fallback_text

    def _generate_text_with_llm(self, category: str, metadata_dict: Dict[str, str]) -> str:
        """LLM을 사용하여 자연스러운 문장 생성"""
        try:
            metadata_str = ", ".join([f"{k}: {v}" for k, v in metadata_dict.items()])
            instruction = self.category_instructions.get(category, self.default_instruction)

            # category_instruction에 metadata를 포맷팅
            #  {값} 같은 예시 템플릿을 이스케이프하기 위해 먼저 {{ }} 처리
            # {값} → {{값}}으로 변환하여 .format()이 무시하도록 함
            if "{metadata}" in instruction:
                # 먼저 {값} 같은 예시를 이스케이프
                instruction_escaped = instruction.replace("{값}", "{{값}}")
                instruction = instruction_escaped.format(metadata=metadata_str)
                # 다시 원래대로 복원 (LLM에게는 {값}으로 보여야 함)
                instruction = instruction.replace("{{값}}", "{값}")

            prompt = self.master_template.format(
                metadata=metadata_str,
                category_instruction=instruction.strip()
            )

            response = self.client.messages.create(
                model=self.model,
                max_tokens=256,
                temperature=0.3,
                messages=[{"role": "user", "content": prompt}],
                timeout=30.0  # 30초 타임아웃
            )

            #  응답 내용 안전하게 추출
            if not response.content or len(response.content) == 0:
                logger.warning(f"[WARN] LLM 응답이 비어있음 (category: {category})")
                return ", ".join([f"{k}: {v}" for k, v in metadata_dict.items()])
            
            # 첫 번째 content 블록의 text 추출
            first_content = response.content[0]
            if hasattr(first_content, 'text'):
                text = first_content.text.strip()
            elif isinstance(first_content, str):
                text = first_content.strip()
            else:
                logger.warning(f"[WARN] LLM 응답 형식이 예상과 다름 (category: {category}, type: {type(first_content)})")
                return ", ".join([f"{k}: {v}" for k, v in metadata_dict.items()])
            
            text = text.replace('"', '').replace("'", '').replace('```', '').strip()
            return text
        except KeyError as e:
            logger.error(f"[ERROR] LLM 생성 실패 (KeyError): {e}, category: {category}, metadata: {metadata_dict}")
            return ", ".join([f"{k}: {v}" for k, v in metadata_dict.items()])
        except Exception as e:
            logger.error(f"[ERROR] LLM 생성 실패: {e}, category: {category}, metadata: {metadata_dict}")
            return ", ".join([f"{k}: {v}" for k, v in metadata_dict.items()])
